# 数据基础

- 数组最大的优点：快速查询(根据索引)
- 数组最好应用于”索引有语意“的情况

## 数组特点
### 数组支持随机访问
- a) 数组如何实现下标随机访问。
引入数组再内存种的分配图，得出寻址公式
- b) 纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。

正确表述：**数组支持随机访问，根据下标随机访问的时间复杂度为O（1）**

**注意：**
- 警惕数组的访问越界问题
### 低效的插入和删除
- 1） 插入：从最好O(1) 最坏O(n) 平均O(n)
- 2） 插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明
- 3） 删除：从最好O(1) 最坏O(n) 平均O(n)
- 4） 多次删除集中在一起，提高删除效率

## 数组索引为什么都是从0开始？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：
```c
a[k]_address = base_address + k * type_size
```
但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：
```c
a[k]_address = base_address + (k-1)*type_size
```
对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。

C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。

总结：
- 底层计算机寻址指令可以少计算一个减法
- 历史原因，C 语言设计者用 0 开始计数数组下标

