    # 二分查找法
    二分查找法（Binary Search），对于有序数列（记住：针对已经排好序的数列），才能使用二分查找法。

    ## 二分查找思想

    二分查找，顾名思义，对半分，然后找。

    核心思想分为三大块：

    - 如果目标**等于**分界点的值，那么就**查找成功**，直接返回。
    - 如果目标**小于**分界点的值，那么就去**较小**的区域查找，然后**再对半分**，接着查。
    - 如果目标在*大于**分界点的值，那么就去**较大**的区域查找，然后**再对半分**，接着查。

    大致如图所示：
    ![](../../../img/二分查找思想.png)

    时间复杂度为：`log(n)`

    ## 代码实践
    ### 初步实现
    注释写的很详细了：
    ```go
    // 二分查找法，在有序数组arr中，查找target
    // 如果找到target，返回相应的索引index
    // 如果没有找到target，返回-1
    func binarySearch(arr []int64, n, target int64) int64 {
        var l, r int64
        l = 0
        r = n - 1 // 在arr[l,r]之中查找target，注意：此处是左闭右闭的区间，因为r为 n-1

        for l <= r { // 左区间一定<=有区间，否则无意义
        
            mid := (l + r) / 2 // 定义分界点，即对半分的值
            
            // 如果目标正好等于分界点的值
            if arr[mid] == target {
                return mid
            }

            // 如果目标小于分界点
            if target < arr[mid] {
                // 则在arr[l,mid-1]之中查找
                r = mid - 1
            } else { // 如果目标大于分界点
                // 则在arr[mid+1,r]之中查找
                l = mid + 1
            }
        }
        return -1
    }
    ```

    ### 修改bug
    问题主要出现在分界点的确定：
    ```go
    mid := (l + r) / 2
    ```
    上述写法数据溢出，为什么会溢出呢？

    因为`l`、`r`定义的数据类型是`int64`，其能够存储的数据的范围是：`[-2^63,2^63-1]`。

    假设 `l`= 2^63 - 20，`r` = 2^63 - 1，那么 `(l + r)`变为 `2^64-21`，这个值已经超出了`int64`的范围了，内存无法存放该值。

    那如何修改呢？上诉思路是求平均值的思想，使用加法；换个思路，使用减法如何，改为：
    ```go
    mid = l + (r - l) / 2 
    ```
    这个公式展开后，本质上和` (l + r) / 2`相同，但是这样做便不会有内数据溢出的问题了，因为 `(r - l) / 2 `中已除以2，`r`和`l`的范围缩小了。


